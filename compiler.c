
#include "config.h"

#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include "shell.h"
#include "flags.h"

#include "compiler.h"

static const char bashc_header[] =
"/* This file generated by bashc */\n"
"#include <stdlib.h>\n"
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <sys/types.h>\n"
"#include <sys/wait.h>\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
	"\tint ret;\n"
	"\tpid_t pid;\n"
	"\n"
	"\t(void)argc;\n"
	"\t(void)argv;\n"
	"\t(void)ret;\n"
	"\t(void)pid;\n"
	"\n"
;

static const char bashc_footer[] =
	"\treturn 0;\n"
"}\n"
;

static int output_inited = 0;
static int indent_level = 0;

static void indent(void)
{
	int i;
	for (i = 0; i < indent_level; i++) fputc('\t',bashc_output);
}

#define cout(...) fprintf(bashc_output,__VA_ARGS__)
#define icout(...) do { indent(); cout(__VA_ARGS__); } while (0)
#define icoutn(...) do { indent(); cout(__VA_ARGS__); cout(";\n"); } while (0)

#define make_cif(...) do { \
		indent(); \
		cout("if ("); \
		cout(__VA_ARGS__); \
		cout(") {\n"); \
		++indent_level; \
	} while (0)

#define make_celseif(...) do { \
		--indent_level; \
		indent(); \
		cout("} else if ("); \
		cout(__VA_ARGS__); \
		cout(") {\n"); \
		++indent_level; \
	} while (0)

#define make_celse() do { \
		--indent_level; \
		indent(); \
		cout("} else {\n"); \
		++indent_level; \
	} while (0)

#define make_cendif() do { --indent_level; indent(); cout("}\n"); } while (0)

#define ccomment(...) do { \
		indent(); \
		cout("/* "); \
		cout(__VA_ARGS__); \
		cout(" */\n"); \
	} while (0)

void cencode_string(const char* str)
{
	int i;

	for (i = 0; str[i]; i++) {
		switch (str[i]) {
		case '"': cout("\\\""); break;
		case '\n': cout("\\n"); break;
		case '\r': cout("\\r"); break;
		case '\t': cout("\\t"); break;
		case '\f': cout("\\f"); break;
		case '\v': cout("\\v"); break;
		case '\a': cout("\\a"); break;
		case '\b': cout("\\b"); break;

		default:
			if (isprint(str[i]))
				cout("%c",str[i]);
			else
				cout("\\x%02hhx",str[i]);
		}
	}
}

void wordlist_to_cstr_array(WORD_LIST* wds, int addnullterm)
{
	WORD_LIST* wd;

	cout("{ ");

	for (wd = wds; wd; wd = wd->next) {
		cout("\"");
		cencode_string(wd->word->word);
		cout("\", ");
	}

	if (addnullterm)
		cout("NULL, ");

	cout("}");
}

void compile_simple_command(COMMAND* cmd)
{
	WORD_LIST* word;
	struct simple_com* sc = cmd->value.Simple;

	if (sc->redirects) {
		internal_warning("compilation of redirects NYI (line %d)",
		                 cmd->value.Simple->line);
		return;
	}
	indent();
	cout("/* ");

	for (word = sc->words; word; word = word->next)
		cout("%s%s",word->word->word,word->next ? " " : "");
	cout(" */\n");

	icoutn("pid = fork()");

	make_cif("!pid");

	ccomment("child");
	icout("static char* const argv[] = ");
	wordlist_to_cstr_array(sc->words,1);
	cout(";\n");
	icoutn("execvp(argv[0],argv)");
	icoutn("perror(\"execvp\")");
	icoutn("exit(1)");

	make_celse();

	ccomment("parent");
	icoutn("int status");
	icoutn("waitpid(pid,&status,0)");
	/* set $? to status */
	icoutn("ret = status");

	make_cendif();
	cout("\n");
}

void compile_command(COMMAND* cmd)
{

	switch (cmd->type) {

	case cm_for:
	case cm_case:
	case cm_while:
	case cm_if:
	case cm_select:
	case cm_connection:
	case cm_function_def:
	case cm_until:
	case cm_group:
	case cm_arith:
	case cm_cond:
	case cm_arith_for:
	case cm_subshell:
	case cm_coproc:
		internal_warning("compilation NYI for command type on line %d",
		                 cmd->line);
		return;

	case cm_simple:
		compile_simple_command(cmd);
		break;

	default:
		fatal_error("bad command type in compile_command()");
	}
}

void init_compiler_output(void)
{
	fputs(bashc_header,bashc_output);
	indent_level = 1;
}

void finish_compiler_output(void)
{
	fputs(bashc_footer,bashc_output);
	indent_level = 0;
}

int compile_input(void)
{
	int ret;
	COMMAND* current_command;

	if (!(bashc_output = fopen(bashc_outpath,"w"))) {
		report_error("Failed to open %s for writing",bashc_outpath);
		exit_shell(EX_NOTFOUND);
	}

	init_compiler_output();
	
	while (!EOF_Reached) {
		if (read_command()) {
			ret = 1;
			EOF_Reached = EOF;
		} else if (global_command) {
			compile_command(global_command);
			dispose_command(global_command);
			global_command = NULL;
		}

		if (just_one_command)
			EOF_Reached = EOF;
	}

	finish_compiler_output();

	if (fclose(bashc_output)) {
		report_error("failed to close %s",bashc_outpath);
		return 1;
	}

	return 0;
}
