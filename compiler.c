
#include "config.h"

#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include "shell.h"
#include "flags.h"
#include "builtins.h"
#include "builtins/common.h"
#include "builtins/builtext.h"

#include "compiler.h"

#define NYI(...) internal_warning("NYI: compilation of "__VA_ARGS__)

static const char bashc_header[] =
"/* This file generated by bashc */\n"
"#include <stdlib.h>\n"
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <sys/types.h>\n"
"#include <sys/wait.h>\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
	"\tint mainret;\n"
	"\tint last_cmd_exit_status;\n"
	"\tpid_t pid;\n"
	"\n"
	"\t(void)argc;\n"
	"\t(void)argv;\n"
	"\t(void)last_cmd_exit_status;\n"
	"\t(void)pid;\n"
	"\tmainret = 0;\n"
	"\n"
;

static const char bashc_footer[] =
	"\treturn mainret;\n"
"}\n"
;

static int output_inited = 0;
static int indent_level = 0;

static void indent(void)
{
	int i;
	for (i = 0; i < indent_level; i++) fputc('\t',bashc_output);
}

#define cout(...) fprintf(bashc_output,__VA_ARGS__)
#define icout(...) do { indent(); cout(__VA_ARGS__); } while (0)
#define icoutn(...) do { indent(); cout(__VA_ARGS__); cout(";\n"); } while (0)

#define make_cif(...) do { \
		indent(); \
		cout("if ("); \
		cout(__VA_ARGS__); \
		cout(") {\n"); \
		++indent_level; \
	} while (0)

#define make_celseif(...) do { \
		--indent_level; \
		indent(); \
		cout("} else if ("); \
		cout(__VA_ARGS__); \
		cout(") {\n"); \
		++indent_level; \
	} while (0)

#define make_celse() do { \
		--indent_level; \
		indent(); \
		cout("} else {\n"); \
		++indent_level; \
	} while (0)

#define make_cendif() do { --indent_level; indent(); cout("}\n"); } while (0)

#define ccomment(...) do { \
		indent(); \
		cout("/* "); \
		cout(__VA_ARGS__); \
		cout(" */\n"); \
	} while (0)

static void cencode_string(const char* str)
{
	int i;

	for (i = 0; str[i]; i++) {
		switch (str[i]) {
		case '"': cout("\\\""); break;
		case '\n': cout("\\n"); break;
		case '\r': cout("\\r"); break;
		case '\t': cout("\\t"); break;
		case '\f': cout("\\f"); break;
		case '\v': cout("\\v"); break;
		case '\a': cout("\\a"); break;
		case '\b': cout("\\b"); break;

		default:
			if (isprint(str[i]))
				cout("%c",str[i]);
			else
				cout("\\x%02hhx",str[i]);
		}
	}
}

static void wordlist_to_cstr_array(WORD_LIST* wds, int addnullterm)
{
	WORD_LIST* wd;

	cout("{ ");

	for (wd = wds; wd; wd = wd->next) {
		cout("\"");
		cencode_string(wd->word->word);
		cout("\", ");
	}

	if (addnullterm)
		cout("NULL, ");

	cout("}");
}

static void comment_simple_command(struct simple_com* sc)
{
	WORD_LIST* word;

	icout("/* $ ");
	for (word = sc->words; word; word = word->next)
		cout("%s%s",word->word->word,word->next ? " " : "");
	cout(" */\n");
}

static void compile_simple_command(COMMAND* cmd, int override_builtin);

static void compile_builtin(sh_builtin_func_t* builtin, COMMAND* cmd)
{
	struct simple_com* sc = cmd->value.Simple;

	if (builtin == cd_builtin) {
		comment_simple_command(sc);
		make_cif("chdir(\"%s\")",sc->words->next->word->word);
		icoutn("perror(\"chdir\")");
		make_cendif();
		cout("\n");
	} else if (builtin == echo_builtin) {
		/* cheat and use /bin/echo for now */
		compile_simple_command(cmd,1);
	} else {
		NYI("%s builtin",sc->words->word->word);
	}
}

static void compile_simple_command(COMMAND* cmd, int override_builtin)
{
	sh_builtin_func_t* builtin;
	struct simple_com* sc = cmd->value.Simple;

	if (sc->redirects) {
		NYI("redirects");
		return;
	}

	if (!override_builtin &&
	    (builtin = find_shell_builtin(sc->words->word->word))) {
		compile_builtin(builtin,cmd);
		return;
	}

	comment_simple_command(sc);

	make_cif("!(pid = fork())");

	ccomment("child");
	icout("static char* const argv[] = ");
	wordlist_to_cstr_array(sc->words,1);
	cout(";\n");
	icoutn("execvp(argv[0],argv)");
	icoutn("perror(\"execvp\")");
	icoutn("exit(1)");

	make_celse();

	ccomment("parent");
	icoutn("waitpid(pid,&last_cmd_exit_status,0)");
	icoutn("mainret = last_cmd_exit_status");

	make_cendif();
	cout("\n");
}

static void compile_command(COMMAND* cmd)
{

	switch (cmd->type) {

	case cm_for:
	case cm_case:
	case cm_while:
	case cm_if:
	case cm_select:
	case cm_function_def:
	case cm_until:
	case cm_group:
	case cm_arith:
	case cm_cond:
	case cm_arith_for:
	case cm_subshell:
	case cm_coproc:
		NYI("(command type %d)",cmd->type);
		return;

	case cm_simple:
		compile_simple_command(cmd,0);
		break;

	case cm_connection:
		if (cmd->value.Connection->connector != ';')
			internal_warning("non-';' connections");
		compile_command(cmd->value.Connection->first);
		compile_command(cmd->value.Connection->second);
		break;

	default:
		fatal_error("bad command type in compile_command()");
	}
}

static void init_compiler_output(void)
{
	fputs(bashc_header,bashc_output);
	indent_level = 1;
}

static void finish_compiler_output(void)
{
	fputs(bashc_footer,bashc_output);
	indent_level = 0;
}

int compile_input(void)
{
	int ret;
	COMMAND* current_command;

	if (!(bashc_output = fopen(bashc_outpath,"w"))) {
		report_error("Failed to open %s for writing",bashc_outpath);
		exit_shell(EX_NOTFOUND);
	}

	init_compiler_output();
	
	while (!EOF_Reached) {
		if (read_command()) {
			ret = 1;
			EOF_Reached = EOF;
		} else if (global_command) {
			compile_command(global_command);
			dispose_command(global_command);
			global_command = NULL;
		}

		if (just_one_command)
			EOF_Reached = EOF;
	}

	finish_compiler_output();

	if (fclose(bashc_output)) {
		report_error("failed to close %s",bashc_outpath);
		return 1;
	}

	return 0;
}
