
#include "config.h"

#include <stdio.h>

#if defined (HAVE_UNISTD_H)
#  ifdef _MINIX
#    include <sys/types.h>
#  endif
#  include <unistd.h>
#endif

#include "shell.h"
#include "flags.h"
#include "builtins.h"
#include "builtins/common.h"
#include "builtins/builtext.h"

#include "y.tab.h"

#include "compiler.h"

#define NYI(...) internal_warning("NYI: compilation of "__VA_ARGS__)

static const char bashc_header[] =
"/* This file generated by bashc */\n"
"#include <stdlib.h>\n"
"#include <stdio.h>\n"
"#include <unistd.h>\n"
"#include <sys/types.h>\n"
"#include <sys/wait.h>\n"
"\n"
"#include \"libbashc/libbashc.h\"\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
	"\tint G_status;\n"
	"\n"
	"\t(void)argc;\n"
	"\t(void)argv;\n"
	"\tG_status = 0;\n"
	"\n"
;

static const char bashc_footer[] =
	"\treturn G_status;\n"
"}\n"
;

static int output_inited = 0;
static int indent_level = 0;

static void indent(void)
{
	int i;
	for (i = 0; i < indent_level; i++) fputc('\t',bashc_output);
}

#define cout(...) fprintf(bashc_output,__VA_ARGS__)
#define coutn(...) do { fprintf(bashc_output,__VA_ARGS__); cout("\n"); } while (0)
#define icout(...) do { indent(); cout(__VA_ARGS__); } while (0)
#define icoutsn(...) do { indent(); cout(__VA_ARGS__); cout(";\n"); } while (0)

#define make_cif(...) do { \
		indent(); \
		cout("if ("); \
		cout(__VA_ARGS__); \
		cout(") {\n"); \
		++indent_level; \
	} while (0)

#define make_celseif(...) do { \
		--indent_level; \
		indent(); \
		cout("} else if ("); \
		cout(__VA_ARGS__); \
		cout(") {\n"); \
		++indent_level; \
	} while (0)

#define make_celse() do { \
		--indent_level; \
		indent(); \
		cout("} else {\n"); \
		++indent_level; \
	} while (0)

#define make_cendif() do { --indent_level; indent(); cout("}\n"); } while (0)

#define ccomment(...) do { \
		indent(); \
		cout("/* "); \
		cout(__VA_ARGS__); \
		cout(" */\n"); \
	} while (0)

#define startblock() do { icout("{\n"); ++indent_level; } while (0)
#define endblock() do { --indent_level; icout("}\n"); } while (0)

static void cencode_string(const char* str)
{
	int i;

	for (i = 0; str[i]; i++) {
		switch (str[i]) {
		case '"': cout("\\\""); break;
		case '\n': cout("\\n"); break;
		case '\r': cout("\\r"); break;
		case '\t': cout("\\t"); break;
		case '\f': cout("\\f"); break;
		case '\v': cout("\\v"); break;
		case '\a': cout("\\a"); break;
		case '\b': cout("\\b"); break;

		default:
			if (isprint(str[i]))
				cout("%c",str[i]);
			else
				cout("\\x%02hhx",str[i]);
		}
	}
}

/* Returns a pointer to a malloc()ed string of the name of a new
 * variable, with option "base" name */
static char* new_variable(const char* base)
{
	static unsigned int idnum = 0;
	char buf[128];
	const char* baseid = base ? base : "var";
	sprintf(buf,"%s%u",base,idnum++);
	return strdup(buf);
}

static void wordlist_to_cstr_array(WORD_LIST* wds, int addnullterm)
{
	WORD_LIST* wd;

	cout("{ ");

	for (wd = wds; wd; wd = wd->next) {
		cout("\"");
		cencode_string(wd->word->word);
		cout("\", ");
	}

	if (addnullterm)
		cout("NULL, ");

	cout("}");
}

static void compile_simple_command(COMMAND* cmd, int override_builtin);
static void compile_command(COMMAND* cmd);

static void comment_simple_command(struct simple_com* sc)
{
	WORD_LIST* word;

	icout("/* $ ");
	for (word = sc->words; word; word = word->next)
		cout("%s%s",word->word->word,word->next ? " " : "");
	cout(" */\n");
}

static void compile_builtin(sh_builtin_func_t* builtin, COMMAND* cmd)
{
	struct simple_com* sc = cmd->value.Simple;

	if (builtin == cd_builtin) {
		comment_simple_command(sc);
		make_cif("chdir(\"%s\")",sc->words->next->word->word);
		icoutsn("perror(\"chdir\")");
		make_cendif();
		cout("\n");
	} else if (builtin == echo_builtin) {
		/* cheat and use /bin/echo for now */
		compile_simple_command(cmd,1);
	} else {
		NYI("%s builtin",sc->words->word->word);
	}
}

static void compile_simple_command(COMMAND* cmd, int override_builtin)
{
	sh_builtin_func_t* builtin;
	struct simple_com* sc = cmd->value.Simple;
	char* argvname = new_variable("argv");

	if (sc->redirects) {
		NYI("redirects");
		return;
	}

	if (!override_builtin &&
	    (builtin = find_shell_builtin(sc->words->word->word))) {
		compile_builtin(builtin,cmd);
		return;
	}

	comment_simple_command(sc);

	startblock();
	icout("static char* const %s[] = ",argvname);
	wordlist_to_cstr_array(sc->words,1);
	cout(";\n");
	icoutsn("G_status = exec_argv(%s)",argvname);
	endblock();
	cout("\n");

	free(argvname);
}

static int pipe_length(COMMAND* head)
{
	COMMAND* next = head;
	int len = 1;
	for (;;) {
		if (next->type != cm_connection)
			return len;
		if (next->value.Connection->connector != '|')
			return len;
		++len;
		next = next->value.Connection->second;
	}
}

static void compile_pipe(COMMAND* first, COMMAND* second)
{
	char* pipeends;
	char* pids;
	int i;
	int len = pipe_length(second);

	pipeends = new_variable("pipe");
	pids = new_variable("pids");

	startblock();

	icoutsn("int %s[%d][2]",pipeends,len);

	icout("if (!pipe(%s[0])",pipeends);
	for (i = 1; i < len; i++)
		cout(" && !pipe(%s[%i])",pipeends,i);
	coutn(") {");
	++indent_level;

	make_celse();

	icoutsn("perror(\"pipe\")");

	make_cendif();

	endblock();
	cout("\n");

	free(pipeends);
	free(pids);
}

static void compile_connection(COMMAND* cmd)
{
	struct connection* conn = cmd->value.Connection;

	switch (cmd->value.Connection->connector) {
	case ';':
		compile_command(conn->first);
		compile_command(conn->second);
		break;

	case '|':
		compile_pipe(conn->first,conn->second);
		return;

	case '&':
	case AND_AND:
	case OR_OR:
		NYI("&, &&, and || connectors");
		return;

	default:
		fatal_error("bad connector type in compile_connection");
		
	}
}

static void compile_command(COMMAND* cmd)
{

	switch (cmd->type) {

	case cm_for:
	case cm_case:
	case cm_while:
	case cm_if:
	case cm_select:
	case cm_function_def:
	case cm_until:
	case cm_group:
	case cm_arith:
	case cm_cond:
	case cm_arith_for:
	case cm_subshell:
	case cm_coproc:
		NYI("(command type %d)",cmd->type);
		return;

	case cm_simple:
		compile_simple_command(cmd,0);
		break;

	case cm_connection:
		compile_connection(cmd);
		break;

	default:
		fatal_error("bad command type in compile_command()");
	}
}

static void init_compiler_output(void)
{
	fputs(bashc_header,bashc_output);
	indent_level = 1;
}

static void finish_compiler_output(void)
{
	fputs(bashc_footer,bashc_output);
	indent_level = 0;
}

int compile_input(void)
{
	int ret;
	COMMAND* current_command;

	if (!(bashc_output = fopen(bashc_outpath,"w"))) {
		report_error("Failed to open %s for writing",bashc_outpath);
		exit_shell(EX_NOTFOUND);
	}

	init_compiler_output();
	
	while (!EOF_Reached) {
		if (read_command()) {
			ret = 1;
			EOF_Reached = EOF;
		} else if (global_command) {
			compile_command(global_command);
			dispose_command(global_command);
			global_command = NULL;
		}

		if (just_one_command)
			EOF_Reached = EOF;
	}

	finish_compiler_output();

	if (fclose(bashc_output)) {
		report_error("failed to close %s",bashc_outpath);
		return 1;
	}

	return 0;
}
